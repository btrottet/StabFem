///
// THIS PROGRAM IS ADAPTED FROM Eigen_Bridge_Potential.edp from LiquidBridges++_V1.3
// THIS PROGRAM IS ADAPTED FROM Cylinder_VIV.edp
//
//  Computation of the eigenvalues and eigenvectors for oscillations of a liquid bridge and free sphere
//  (inviscid theory)
// ----------------------------------------
// the problem is potential : u = i grad (phi) (mind the "i" factor !) 
// PROBLEM_FLUID : find $\omega$ and $[phi,eta]$  such that
// 	$$ \Delta \phi = 0 $$ inside the domain
// 	$$ \omega \phi = \gamma (-(K0a^2+K0b^2) \eta - \partial^2 \eta / \partial s^2 + m^2/r^2 \eta $$ on the free surface
// 	$$ \omega \eta = grad \phi \dot n $$ on the free surface $
//	$$ Coupling equations
// 
//-----------------------------------------

// Remarque : phi et eta sont definis comme des champs P2 sur le volume, meme si eta n'a de sens qu'à la surface


include "Macros_StabFem.edp" // Macros to Write Files

verbosity=0;

real zero=0;

// Physical Parameters
 
real gamma=1;	  // Surface Tension
real R=1;	  // Jet Radius
real dpdz;	  // Gravity Field 0
real MASS=1e-8;	  // Sphere Inertia 0+

// Surface Tension equal to 1
cout << "ENTREZ LA TENSION DE SURFACE GAMMA : "<< endl;
cin >> gamma;
if(gamma != 1){ 
	// TO BE MODIFIED !
	cout << "WARNING : PROGRAM HAS TO BE ADAPTED FOR GAMMA ~= 1"<< endl; 
	exit(-1);
	} ; 

// No Gravity
cout << "ENTREZ LE PARAMETRE DE GRAVITE dp/dz = rho g : "<< endl;
cin >> dpdz;


// Numerical Parameters
real shiftr=0.6;
real shifti=0.6;

int m;  // Wave number

cout << " ENTREZ Le nombre d'onde m ?" << endl;
cin >> m;
cout << "==> Calcul des valeurs propres pour m = " << m << endl;

	// Shift
	cout << " Enter SHIFT (re,im) :   " << endl; 
	cin  >> shiftr >> shifti;
	complex shift = 1i*shifti+shiftr;
	
	// Symmetry
	string symmetry;
	cout << " Symmetry properties ?? (A, S or N)" << endl;
	cin >> symmetry;

	// Problem to solve (D)
	string iadjoint; // 0 for direct ; 1 for adjoint
	cout << " Direct (D), Adjoint (A), or both+sensitivity (S) ?" << endl;
	cin >> iadjoint;	
	
	// Number of eigenvalues to compute 1
	int nev;
	nev=1;
	cout << " Enter nev ? (will use simple shift-invert if nev = 1)" << endl;
	cin >> nev ;
	int ncv = 4*nev;   ///// Krylov Basis
	
	cout << " ### PARAMETERS SELECTED : " << endl;
	cout << " shift = " << shift << endl;
	if (symmetry =="S") {cout << " Symmetric modes" << endl;}
		else if (symmetry =="A") {cout << " Antiymmetric modes" << endl;}	
		else if (symmetry =="N") {cout << " No symmetry axis" << endl;};	
	
	if (iadjoint =="D") {cout << " DIRECT PROBLEM" << endl;}
		else {cout << " ERROR WHEN SELECTING PROBLEM TYPE" << endl;};
	
	cout << " nev = " << nev << endl;
	

////////////////////////////////////////////////////////////////
//
// MAILLAGE ET GEOMETRIE INITIAUX
//
////////////////////////////////////////////////////////////////

// MESH READING (data generated previously by MeshInit_BridgeSphere.edp in SF_Init.m

mesh th=readmesh(ffdatadir+"mesh.msh");
//mesh th=th; //autre nom possible...
mesh Shempty=emptymesh(th); 	// Maillage 'surface'

real L, K0, Vol, Area;

// MACROS FOR CURVATURE NORMAL AND TANGENTIAL VECTOR, SURFACE NUMBERING, CALCGEOMSURF, ETC
include "Macros_Geometrie_Surface.edp"

SurfaceNumbering(IndexPointSurf,xPointSurf,yPointSurf,S0PointSurf,Nsurface); // cf. macro

// COMPUTE NORMAL AND CURVATURE
CalcGeomSurf;

// FUNCTIONAL SPACE : VhxVh for PHI and ETA, Xh for Vb and Xb
fespace VhxVh(th,[P1,P1]);
fespace Xh(th,P1);

VhxVh<complex> [phi,eta],[q,v];

real RegEta = 1e-8;

// CONSTRUCTION DES MATRICES (WEAK FORMULATION) 

//MATRIX AFLUID

varf a([phi,eta],[q,v]) = // order of test fun. shoud be [v,q] for SLEPC ; [q,v] instead
// Laplacian	  
	  int2d(th)(  (dx(phi)*dx(v) + dy(phi)*dy(v)+(m^2+1e-8)*phi*v/(x^2+1e-30))*x  )  //try+ v*dx(phi)/(x+1e-8) ???
	  		// desingularisation term necessary if m=0 ; don't know why
// Curvature	  
	+ int1d(th,2)(((Ds(eta))*(Ds(q))-(K0a^2+K0b^2)*eta*q+m^2/(x^2+1e-30)*q*eta)*abs(x))
// gravity
	+ int1d(th,2)(dpdz*eta*q*N0z*x)
// shift 
	- int1d(th,2)(shift*(eta*v+q*phi)*x)
// Pour regulariser eta dans le volume
	+ int2d(th)((dx(q)*dx(eta)+dy(q)*dy(eta))*RegEta*abs(x)) //  deuxieme idee : laplacien 
// Conditions limites par penalisation
+ int1d(th,1,5)(1e30*eta*q*abs(x)) // pour ligne de contact fixee
+ int1d(th,1)(m*phi*v*1e30) // CL axe pour m different de 0

// CONDITION LIMITE DE DIRICHLET SUR PHI (supprime la condition de neumann orthogonale)
//+ int1d(th,6)(phi*v*1e30*abs(x)); //MARCHE
//+ on(6,phi=0.0); //NE MARCHE PAS
;

//MATRIX BFLUID

varf b([phi,eta],[q,v]) = 
        int1d(th,2)(eta*v*x)
       +int1d(th,2)(q*phi*x)
	//+ int1d(th,6)(phi*v*1e30*abs(x))
;

////////////////////////////////////////////////////
//
//  COUPLING OF MATRIX SYSTEMS
//  
////////////////////////////////////////////////////

//MATRICE OF THE FLUID PROBLEM
matrix<complex> Afluid = a(VhxVh,VhxVh,solver=sparsesolver); 
matrix<complex> Bfluid = b(VhxVh,VhxVh,solver=GMRES,eps=1e-20);

//FORCE FLUID ON SPHERE, COMMENTS : p=-rho*dphi/dt=-omega*phi
varf bfluidvb([q,v],[phi,eta]) = int1d(th,6)(-2*N.y*phi);
complex[int] BFluidVB = bfluidvb(0,VhxVh);

//KINEMATIC CONDITIONS, COMMENTS : NO BASEFLOW => NO FLATTENING
complex[int] BVbFluid(phi[].n);
varf bvbfluid([phi,eta],[q,v]) = int2d(th)(0*v);
BVbFluid = bvbfluid(0,VhxVh);

complex[int] AVbFluid(phi[].n); //absolute referential
varf avbfluid([phi,eta],[q,v]) = int1d(th,6)(N.y*v);  
AVbFluid = avbfluid(0,VhxVh);

//COUPLED SYSTEM : A*X=i*omega*B*X, with: X=[[phi,eta],Xb,Vb]'
matrix<complex> A = [
		[Afluid,AVbFluid,0],
		[0,0,0],
		[0,1,0]
		];

matrix<complex> B = [
		[Bfluid, BVbFluid,0],
		[BFluidVB',MASS,0],
		[0,0,1]
		];

matrix<complex> OP;
complex shiftOP;
shiftOP = shift;
OP = A + (-shiftOP)*B;

////////////////////////////////////////////////////
//
//  RESOLUTION DU PB AUX VALEURS PROPRES
//
//  Important warning : here the computed eigenvalues correspond to omega = lambda/i !
//  
/////////////////////////////////////////////////////

if(nev>1)
/// SOLUTION AND POSTPROCESSING FOR NEV>1 (built-in eigenvalue solver)
{

cout << "BIG WARNING : Nev>1 case not yet handled here !" << endl;
real zero = 0;
cout << 1/zero;
/*

////// BUILD OP-MATRIX=A-sigma*B //////////////////////////////////////////////////////////////
//if(iadjoint=="D")
//{

//}
//else if(iadjoint=="A")
//{
//OP=LNSEadjoint(XXMh,XXMh,solver=sparsesolver);
//shiftOP = conj(shift);
//}
//else if(iadjoint=="S")
//{
//cout << " WARNING : in this program option S will work only for nev=1" << endl;
//};

////////////////////////////////////////////////////////////////////////////////////


complex[int] ev(nev);                     ////// vector to store eigenvaluesJ'ai aussi une autre chose qui pose problème, 
XXMh<complex> [int] [eu1,eu2,eup](nev);   ////// vector to store EIGENVECTORS 

complex[int,int] EVectors(u1[].n+2,nev); 

///////////////////// CALL TO ARPACK++ ////////////////////////////////// //////////
//int k=EigenValue(OP,B,sigma=shiftOP,value=ev,vector=EVectors,tol=1e-6,maxit=0,ncv=ncv);    //Arpack call



//if(iadjoint=="A") { ev = conj(ev); } ;
////////////////////////////////////////////////////////////////////////////////////


	fespace p1(Th,P1); 
	p1 xx,yy;
	xx=x;
	yy=y;
    p1<complex> ux1,uy1,pp1,vort1;
	
    string namefile;
    
    if(iadjoint=="D"){namefile="Eigenvalues.txt";}
    else {namefile="EigenvaluesA.txt";};
    
    real Vb,Xb;
    ofstream fileVP1(namefile); 
	for (int i=0;i<nev;i++)
	{
       fileVP1 << real(ev[i]) << " " << imag(ev[i]) << " " << Re << " " << 0 << " " << real(shift) << " " << imag(shift) << endl;
       	cout << " valeur propre : " << i+1 << "  : " << ev[i] << endl;
		{
 		 if(iadjoint=="D"){namefile="Eigenmode"+(i+1)+".ff2m";}
 		 else{namefile="EigenmodeA"+(i+1)+".ff2m";};
 		 cout << "Writing eigenmode in file " << namefile << endl;
 		 ofstream file(namefile);
 		 file << "### Data generated by Freefem++ ; " << endl;
    	 file << "EIGENMODE for the flow around a 2D cylinder" << endl;
    	 file << "Format :" << endl;
	     file << "real Re  complex sigma complex shift P1c ux1 P1c uy1 P1c p1 P1c vort1 complex Xbody complex Vbody" << endl << endl ; 
		 file << Re  << endl << real(ev[i]) << " " << imag(ev[i]) << " " << shiftr << " " << shifti << endl << endl;
// 		[u1[],Vb,Xb] = EVectors(:,i); does not work
 		ux1 = u1 ; 
J'ai aussi une autre chose qui pose problème,  		uy1 = u2 ;
 		pp1 = p1;
// 		ux1=eu1[i];
//		uy1=eu2[i];
//		pp1=eup[i];
		vort1=dy(u1)-dx(u2);
		for (int j=0;j<ux1[].n ; j++) file << real(ux1[][j]) << " " << imag(ux1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(uy1[][j]) << " " << imag(uy1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(pp1[][j]) << " " << imag(pp1[][j]) << endl;
		for (int j=0;j<ux1[].n ; j++) file << real(vort1[][j]) << " " << imag(vort1[][j]) << endl;
		};
	};
	cout << "it's done" << endl;
	*/
}


////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


else

//// SIMPLE SHIFT-INVERT METHOD IF ONLY ONE MODE IS RESQUESTED
{

VhxVh<complex> [phi0,eta0],[phidirect,etadirect],[phiadjoint,etaadjoint]; 
[phi0,eta0] = [1,1];

// selection of the computation to be performed : direct, adjoint or both
		
int directadjointA,directadjointB;
directadjointA = 1; directadjointB=1;
cout << "Shift-invert algorithm for DIRECT problem" << endl;
	
	// LOOP TO SELECT WHICH COMPUTATION WILL BE DONE 
	for(int directadjoint=directadjointA;directadjoint<directadjointB+1;directadjoint++)	
	{

	cout << " Constructing operator for DIRECT problem ..." << endl;
	//OP=LNSE(XXMh,XXMh,solver=sparsesolver);
	shiftOP = shift;
	cout << " solving DIRECT problem ..." << endl;

	int itmax = 100;
	complex sigma0 = 1e6;
	real err = 1e6;
	real errmax=1e-6;
	complex sigma;
	
	//varf brhs([u1,u2,p],[v1,v2,q]) = int2d(Th)( (u10*v1+u20*v2) );
	set(OP,solver=sparsesolver);  //// factorize matrix

	complex Vb0=0; complex Xb0=0;
	complex Vb,Xb;

	/// ITERATION LOOP
	int i;
	for (i=0; ((err>errmax)&&(i<itmax)); i++)
	{
    	complex[int] X0 = [phi0[],Vb0,Xb0];
    	complex[int] rhs= B*X0;  //////// see freefem++doc.pdf for the solver 
		complex[int] X = OP^-1*rhs;

		//cout << " X = " << X << endl;
		[phi[],Vb,Xb] = X;

		complex XnXn1 = int2d(th)(phi0*phi+eta0*eta)+Vb0*Vb+Xb0*Xb;
		complex Xn1Xn1 = int2d(th)(phi*phi+eta*eta)+Vb*Vb+Xb*Xb;
		complex GG = Xn1Xn1/XnXn1;
		// at each step the inverse shifted eigenval. is approximated by <X_{n+1}, Y> / <X_n, Y>
		//      ( the choice Y = X_{n+1} is convenient but we could choose something else )
		sigma = shiftOP+1/GG;
		err = abs(sigma-sigma0);
		cout << " iteration " << i+1 << " : " << endl;	
		//	cout << " GG = " << GG << endl;
		//	cout << " XnXn = " << XnXn << endl;
		cout << " estimated eigenvalue sigma = " << sigma << endl;	 
		phi0[] = 1/sqrt(abs(Xn1Xn1))*phi[];
		Vb0 = 1/sqrt(abs(Xn1Xn1))*Vb;
		Xb0 = 1/sqrt(abs(Xn1Xn1))*Xb;
		sigma0 = sigma;
	};
	/// END ITERATION LOOP	

 	// normalization by MAXIMUM
 	Xh NormU = sqrt(abs(Vb)^2);
	phi[] = 1/NormU[].max*phi[];
	Vb = 1/NormU[].max*Vb;
	Xb = 1/NormU[].max*Xb;
	 
	if(i<itmax)
	// POST-PROCESSING if iteration was successful
	{	

		//eigenvalue computed

		cout << " ### VP Calculees :" << endl;
		real sigmar = real(sigma) ; real sigmai = imag(sigma);

		string namefile,namefileFF,descriptionFF;

    		ofstream file("Spectrum.txt");
    		file << sigmar << " " << sigmai << " " << real(shift) << " " << imag(shift) << endl;
    		namefile="Eigenmode.txt";
    		namefileFF="Eigenmode.ff2m";
    		descriptionFF="complex sigma complex shift int iter P1c phi P1surfc eta complex Vb complex Xb"; //problem???
	
		//{
		//ofstream file(namefile);
		//file << phi[] ;	
		//file << endl
		//<< endl << sigmar << "   " << sigmai  << endl;
		//}
    
	fespace p1(th,P1); 
	p1 xx,yy;
	xx=x;
	yy=y;
	p1<complex> phi,eta;

		cout << "Writing eigenmode in file " << namefileFF << endl;
		ofstream fileFF(namefileFF);
		fileFF << "### Data generated by Freefem++ ; " << endl;
		fileFF << "EigenMode" << endl;
		fileFF << "Format :" << endl;
		fileFF << descriptionFF << endl << endl ; 
		fileFF << real(sigma) << " " << imag(sigma)  
		 << " " << shiftr << " " << shifti << " " << i << endl << endl;
		for (int j=0;j<phi[].n ; j++) fileFF << real(phi[][j]) << " " << imag(phi[][j]) << endl;
		fileFF << endl;
		for(int ksurf=Nsurface;ksurf>-1;ksurf--) 
	     	{ fileFF << real(eta(xPointSurf(ksurf), yPointSurf(ksurf) )) << imag(eta(xPointSurf(ksurf), yPointSurf(ksurf) )) << endl; 
		};
		fileFF << endl;
		fileFF << real(Vb) << " " << imag(Vb) << endl;
		fileFF << real(Xb) << " " << imag(Xb) << endl;
		fileFF << endl;

cout << " Vb : " << Vb << endl;
p1 realphi = real(phi);
plot(realphi,fill=1,value=1);
	
} // end of post processing of simple shift-invert case



else // case iteration failed
{
	cout << " ERROR : shift-invert iteration failed ; shift is probably wrong" << endl;
//	exec("rm Eigenmode.txt");
//	exec("rm EigenmodeA.txt");
	//exec("rm Eigenmode.ff2m");
	//exec("rm EigenmodeA.ff2m");
	{string namefileFF="Eigenmode.ff2m";
 	ofstream fileFF(namefileFF);
 		 fileFF << "### Data generated by Freefem++ ; " << endl;
    	 fileFF << "EIGENMODE for a 2D flow" << endl;
    	 fileFF << "Format :" << endl;
	     fileFF << "int iter" << endl << endl ; 
		 fileFF << -1 << endl;}
	exec("cp Eigenmode.ff2m EigenmodeA.ff2m");
	{ofstream file("Eigenvalues.txt");
    		file << " 0 0 0 0 0 " << endl;}
	exec("cp Eigenvalues.txt EigenvaluesA.txt");    		

};


}; //end of loop for direct/adjoint/selection

// end of selection of mutliple mode (krylov) / single mode (simple shift-invert)
};


